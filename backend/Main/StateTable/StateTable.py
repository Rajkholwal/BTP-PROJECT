import random
import os
from graphviz import Digraph
import cairosvg
from itertools import product

def get_svg_from_file(filepath):
    with open(filepath, "r") as f:
        return f.read()

def generate_question_ST(level):
    flag = random.randint(1, 3)
    if(flag==1):
        question_text, option, correct_answer, images = generate_state_table_mealy_svg()
    elif(flag==2):
        question_text, option, correct_answer, images = generate_state_table_moore_svg()
    elif(flag==3):
        question_text, option, correct_answer, images = identify_seq()

    return (question_text, option, correct_answer, [get_svg_from_file(image) for image in images])

def get_random_filename():
    return f"sequence_img_{random.randint(1, 10000)}"

def Seq_ST_Question_text_generator():
    question_text="For given state table of a finite state machine (FSM). Based on the transitions in the state table, select the sequence that this FSM is designed to detect from the options below."
    return question_text
def ST_Question_text_generator():
    question_text="Given the state transition table of a finite state machine, identify the type of state machine based on this state table."
    return question_text
def generate_sequence():
    length = random.choice([3, 4])  # Randomly choose 3 or 4
    sequences = [''.join(bits) for bits in product('01', repeat=length) if len(set(bits)) > 1]
    
    return random.choice(sequences)  # Randomly select one sequence

def generate_state_table_NONOVER(a):
    n = len(a)  # Length of the input pattern
    statetable = {}
    c=''
    d=''
    # Initialize the states S0, S1, ..., S_n
    for i in range(n + 1):
        statetable[f'S{i}'] = {str(bit): f'S{i}' for bit in range(2)}
        statetable[f'S{i}']['output'] = '0'

    # Fill in the transitions based on the input sequence 'a'
    for i in range(n):
        current_state = f'S{i}'
        next_state = f'S{i+1}'
        if i > 0:
            Opp_char=str(1-int(a[i]))
            d=c+Opp_char
            e=is_left_substring_match_from_start(d,a)
            statetable[current_state][Opp_char]=f'S{e}'

        
        c=c+a[i]
        statetable[current_state][a[i]] = next_state

    statetable[f'S{n}']['0']=f'S{0}'
    statetable[f'S{n}']['1']=f'S{0}'
    
    statetable[f'S{n}']['output'] = '1'
    #print(c)
    return statetable

def generate_state_table_OVER(a):
    n = len(a)  # Length of the input pattern
    statetable = {}
    c=''
    d=''
    # Initialize the states S0, S1, ..., S_n
    for i in range(n + 1):
        statetable[f'S{i}'] = {str(bit): f'S{i}' for bit in range(2)}
        statetable[f'S{i}']['output'] = '0'

    # Fill in the transitions based on the input sequence 'a'
    for i in range(n):
        current_state = f'S{i}'
        next_state = f'S{i+1}'
        if i > 0:
            Opp_char=str(1-int(a[i]))
            d=c+Opp_char
            e=is_left_substring_match_from_start(d,a)
            statetable[current_state][Opp_char]=f'S{e}'

        
        c=c+a[i]
        statetable[current_state][a[i]] = next_state   
        
    
    d=c[1:]+'0'
    e=is_left_substring_match_from_start(d,a)
    statetable[f'S{n}']['0']=f'S{e}'
    d=c[1:]+'1'
    e=is_left_substring_match_from_start(d,a)
    statetable[f'S{n}']['1']=f'S{e}'
    



    statetable[f'S{n}']['output'] = '1'
    #print(c)
    return statetable

def is_left_substring_match_from_start(str1, str2):
    # Iterate through `str1`, generating substrings by removing characters from the left side
    for i in range(len(str1)):
        # Current substring of `str1` generated by removing left characters
        current_substring = str1[i:]
        
        # Check if `str2` starts with the current substring
        if str2.startswith(current_substring):
            return len(current_substring)
            
    return 0

def generate_state_table_moore_svg(image_dir="StateTable/images"):
    
    sequence = generate_sequence()
    
    # Create the image directory if it doesn't exist
    os.makedirs(image_dir, exist_ok=True)

    # Generate the state table (either overlapping or non-overlapping)
    flag=random.choice([True, False])
    if flag:
        statetable = generate_state_table_OVER(sequence)
    else:
        statetable = generate_state_table_NONOVER(sequence)
    
    # Create a new Digraph object for SVG rendering
    dot = Digraph(format='svg')
    
    # Start building the table as an HTML-like structure for Graphviz
    table = (
        '<<TABLE BORDER="1" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">'
        '<TR><TD><B>Current State</B></TD><TD><B>Next State (x=0)</B></TD>'
        '<TD><B>Next State (x=1)</B></TD><TD><B>Output</B></TD></TR>'
    )
    
    # Populate the table rows with the state transitions
    for state, transitions in statetable.items():
        next_state_0 = transitions['0']
        next_state_1 = transitions['1']
        output_ = transitions['output']
        
        # Add each row to the table
        table += f'<TR><TD>{state}</TD><TD>{next_state_0}</TD>'
        table += f'<TD>{next_state_1}</TD><TD>{output_}</TD></TR>'
    
    # Close the table tag
    table += '</TABLE>>'
    
    # Add the table as a single node to the graph
    dot.node('table', label=table, shape='plain')

    # Generate question and options
    question_text = ST_Question_text_generator()
    options = ["Overlapping Moore State Machine", "Overlapping Mealy State Machine","Nonoverlapping Moore State Machine","Nonoverlapping Mealy State Machine"]
    if flag:
       correct_answer = options[0]
    else:
        correct_answer = options[2]
    random.shuffle(options)
    
    # Generate a random filename for the SVG
    svg_filename = os.path.join(image_dir, get_random_filename())
    
    # Render the SVG file
    dot.render(svg_filename)
    
    # Return the question, options, correct answer, and the path to the SVG file
    return question_text, options, correct_answer, [f"{svg_filename}.svg"]


def over_mealy(sequence):
    n = len(sequence)
    states = [f'S{i}' for i in range(n+1)]
    transitions = {state: {} for state in states}

    def find_fallback_state(index, symbol):
        # Find the longest suffix of the sequence that could be a prefix with the new symbol
        for i in range(index, 0, -1):
            if sequence[:i] == sequence[index-i+1:index] + symbol:
                return states[i]
        return states[0]

    for i in range(n):
        current_state = states[i]
        next_state = states[i+1]
        char = sequence[i]

        for symbol in '01':
            if symbol == char:
                transitions[current_state][symbol] = (next_state, '1' if i == n-1 else '0')
            else:
                fallback_state = find_fallback_state(i, symbol)
                transitions[current_state][symbol] = (fallback_state, '0')

    # Ensure all transitions are defined for the final state
    final_state = states[-1]
    for symbol in '01':
        fallback_state = find_fallback_state(n, symbol)
        transitions[final_state][symbol] = (fallback_state, '0')

    return states, transitions
def nonover_mealy(sequence):
    n = len(sequence)
    states = [f'S{i}' for i in range(n+1)]
    transitions = {state: {} for state in states}

    def find_fallback_state(index, symbol):
        # Find the longest suffix of the sequence that could be a prefix with the new symbol
        for i in range(index, 0, -1):
            if sequence[:i] == sequence[index-i+1:index] + symbol:
                return states[i]
        return states[0]

    for i in range(n):
        current_state = states[i]
        next_state = states[i+1]
        char = sequence[i]

        for symbol in '01':
            if symbol == char:
                transitions[current_state][symbol] = (next_state, '1' if i == n-1 else '0')
            else:
                fallback_state = find_fallback_state(i, symbol)
                transitions[current_state][symbol] = (fallback_state, '0')

    # Ensure all transitions are defined for the final state
    final_state = states[-1]
    for symbol in '01':
        transitions[final_state][symbol] = ("S0", '0')

    return states, transitions

def generate_state_table_mealy_svg(image_dir="StateTable/images"):
    
    sequence = generate_sequence()
    
    os.makedirs(image_dir, exist_ok=True)
    flag=random.choice([True, False])
    if flag:
        state, transitions = over_mealy(sequence)
    else:
        state, transitions = nonover_mealy(sequence)
    
    # Create a new Digraph object
    dot = Digraph(format='svg')
    
    # Start building an HTML-like table with column headers for Mealy FSM
    table = '<<TABLE BORDER="1" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">'
    table += '<TR><TD><B>Current State</B></TD><TD><B>Next State (x=0)</B></TD><TD><B>Output (x=0)</B></TD><TD><B>Next State (x=1)</B></TD><TD><B>Output (x=1)</B></TD></TR>'

    # Iterate over the state transitions to fill the rows of the table
    for state, transitions_for_state in transitions.items():
        # Extract next state and output for x=0 and x=1
        next_state_0, output_0 = transitions_for_state['0']
        next_state_1, output_1 = transitions_for_state['1']
        
        # Add a row for the current state with columns for x=0 and x=1 transitions
        table += f'<TR><TD>{state}</TD><TD>{next_state_0}</TD><TD> {output_0}</TD><TD>{next_state_1}</TD><TD> {output_1}</TD></TR>'
    
    table += '</TABLE>>'

    # Add the table as a single node
    dot.node('table', label=table, shape='plain')

    question_text = ST_Question_text_generator()
    
    options = ["Overlapping Moore State Machine", "Overlapping Mealy State Machine","Nonoverlapping Moore State Machine","Nonoverlapping Mealy State Machine"]
    if flag:
       correct_answer = options[1]
    else:
        correct_answer = options[3]
    random.shuffle(options)
    svg_filename = os.path.join(image_dir, get_random_filename())

    # Render the SVG file
    dot.render(svg_filename)
    
    return question_text, options, correct_answer, [f"{svg_filename}.svg"]

def identify_seq(image_dir="StateTable/images"):
    
    sequence = generate_sequence()
    
    os.makedirs(image_dir, exist_ok=True)
    state, transitions = over_mealy(sequence)
    
    # Create a new Digraph object
    dot = Digraph(format='svg')
    
    # Start building an HTML-like table with column headers for Mealy FSM
    table = '<<TABLE BORDER="1" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">'
    table += '<TR><TD><B>Current State</B></TD><TD><B>Next State (x=0)</B></TD><TD><B>Output (x=0)</B></TD><TD><B>Next State (x=1)</B></TD><TD><B>Output (x=1)</B></TD></TR>'

    # Iterate over the state transitions to fill the rows of the table
    for state, transitions_for_state in transitions.items():
        # Extract next state and output for x=0 and x=1
        next_state_0, output_0 = transitions_for_state['0']
        next_state_1, output_1 = transitions_for_state['1']
        
        # Add a row for the current state with columns for x=0 and x=1 transitions
        table += f'<TR><TD>{state}</TD><TD>{next_state_0}</TD><TD> {output_0}</TD><TD>{next_state_1}</TD><TD> {output_1}</TD></TR>'
    
    table += '</TABLE>>'

    # Add the table as a single node
    dot.node('table', label=table, shape='plain')

    question_text = ST_Question_text_generator()
    
    correct_answer=sequence
    options=[correct_answer,generate_sequence(),generate_sequence(),generate_sequence()]
    random.shuffle(options)
    svg_filename = os.path.join(image_dir, get_random_filename())

    # Render the SVG file
    dot.render(svg_filename)
    
    return question_text, options, correct_answer, [f"{svg_filename}.svg"]

